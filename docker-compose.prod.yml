version: '3.8'

services:
  # 1. Serviço da API (Backend Go)
  api:
    build:
      context: . # Constrói a partir da raiz do projeto
      dockerfile: Dockerfile # Usa o Dockerfile que criámos
    restart: always
    env_file:
      - .env # Carrega as variáveis de ambiente (JWT_SECRET, DB_HOST, etc.)
    depends_on:
      - postgres # Só inicia a API depois da base de dados
    networks:
      - appfitness-network
    # Não expomos a porta 8080 ao público; o Caddy irá acedê-la.

  # 2. Serviço do Web Server (Frontend Caddy)
  web:
    image: caddy:2-alpine # Usamos a imagem oficial do Caddy
    restart: always
    ports:
      - "80:80"   # Expõe a porta 80 (HTTP) ao público
      - "443:443" # (O Caddy tratará de HTTPS automaticamente se tiver um domínio)
    volumes:
      # Monta a build do nosso frontend (que ainda vamos gerar)
      - ./frontend/dist:/srv/app
      # Monta o nosso ficheiro de configuração do Caddy
      - ./Caddyfile:/etc/caddy/Caddyfile
    depends_on:
      - api # Só inicia o web server depois da API
    networks:
      - appfitness-network

  # 3. Serviço da Base de Dados (PostgreSQL)
  postgres:
    image: postgres:14-alpine
    restart: always
    env_file:
      - .env # Carrega as passwords a partir do .env
    volumes:
      # Usa um volume persistente para os dados
      - appfitness-data:/var/lib/postgresql/data
      # Carrega o ficheiro de inicialização
      - ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - appfitness-network
    # Não expomos mais a porta 5433 ao público por segurança

volumes:
  appfitness-data: # Define o volume persistente

networks:
  appfitness-network:
    driver: bridge